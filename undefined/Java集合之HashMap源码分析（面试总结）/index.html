<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础梳理,数据结构,hashMap," />










<meta name="description" content="梳理HahsMap知识，文章结构及思路如下：​​ 一、主要特点底层实现是 链表数组+红黑树，拉链法key 用 Set 存放，不允许重复，key 如果用对象则需要重写 hashCode 和 equals 方法允许空键和空值，但空键只有一个元素是无序的，而且顺序会不定时改变插入、获取的时间复杂度基本是 O(1)（前提是有适当的哈希函数，让元素分布在均匀的位置）两个关键因子：初始容量、加载因子 二、继承">
<meta property="og:type" content="article">
<meta property="og:title" content="hashMap知识梳理">
<meta property="og:url" content="http://example.com/undefined/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%89/index.html">
<meta property="og:site_name" content="巴卡玛卡">
<meta property="og:description" content="梳理HahsMap知识，文章结构及思路如下：​​ 一、主要特点底层实现是 链表数组+红黑树，拉链法key 用 Set 存放，不允许重复，key 如果用对象则需要重写 hashCode 和 equals 方法允许空键和空值，但空键只有一个元素是无序的，而且顺序会不定时改变插入、获取的时间复杂度基本是 O(1)（前提是有适当的哈希函数，让元素分布在均匀的位置）两个关键因子：初始容量、加载因子 二、继承">
<meta property="og:locale">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020122320070420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzY2NDE3,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2020-12-24T00:36:47.600Z">
<meta property="article:modified_time" content="2020-12-24T00:39:43.902Z">
<meta property="article:author" content="人和">
<meta property="article:tag" content="基础梳理">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="hashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2020122320070420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzY2NDE3,size_16,color_FFFFFF,t_70#pic_center">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/undefined/Java集合之HashMap源码分析（面试总结）/"/>





  <title>hashMap知识梳理 | 巴卡玛卡</title>
  








<meta name="generator" content="Hexo 5.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">巴卡玛卡</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">subTitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>
<a target="_blank" rel="noopener" href="https://github.com/renhe1997" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/undefined/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="人和">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/panda.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="巴卡玛卡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">hashMap知识梳理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-24T08:36:47+08:00">
                2020-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>梳理HahsMap知识，文章结构及思路如下：<br>​​<img src="https://img-blog.csdnimg.cn/2020122320070420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzY2NDE3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="一、主要特点"><a href="#一、主要特点" class="headerlink" title="一、主要特点"></a>一、主要特点</h2><p>底层实现是 链表数组+红黑树，拉链法<br>key 用 Set 存放，不允许重复，key 如果用对象则需要重写 hashCode 和 equals 方法<br>允许空键和空值，但空键只有一个<br>元素是无序的，而且顺序会不定时改变<br>插入、获取的时间复杂度基本是 O(1)（前提是有适当的哈希函数，让元素分布在均匀的位置）<br>两个关键因子：初始容量、加载因子</p>
<h2 id="二、继承关系"><a href="#二、继承关系" class="headerlink" title="二、继承关系"></a>二、继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">        implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br></pre></td></tr></table></figure>
<h2 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h2><p>数组+链表+红黑树（JDK1.8增加了红黑树部分）</p>
<h3 id="主要元素"><a href="#主要元素" class="headerlink" title="主要元素"></a>主要元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 默认初始容量16——必须是2的幂</span><br><span class="line"> * 01向左补四位，2的四次方</span><br><span class="line"> * hashCode &amp; (length-1); 15位与14位相比，与hashcode相与会有更多的结果，且不浪费空间</span><br><span class="line"> * 所以将length定位二次幂，在进行hash运算时，不同的key算得index相同的几率较小，那么数据在数组上分布就比较均匀，</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 最大容量,必须是2的幂 2的30次方</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 载荷因子</span><br><span class="line"> *&#x2F;</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * treeify_threshold由链表转化为红黑书的阀值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 红黑树节点转换链表节点的阈值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 转红黑树时数组应该满足的长度</span><br><span class="line">     * 至少是 4 * TREEIFY_THRESHOLD ，节省效率</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 基本的哈希节点,链表节点, 继承自Entry</span><br><span class="line">     * k，v是Map&lt;k,v&gt;传入的数据类型</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue &#x3D; value;</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            &#x2F;&#x2F;存储位置相同</span><br><span class="line">            if (o &#x3D;&#x3D; this) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;instanceof是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                return Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, </span><br><span class="line">    e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。</span><br><span class="line">    &#x2F;&#x2F;table数组</span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line">     * for keySet() and values().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 大小</span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 转化为红黑树的阀值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int threshold;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 哈希表的负载系数。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final float loadFactor;</span><br></pre></td></tr></table></figure>
<p>好的Hash算法和扩容机制，可以使Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少</p>
<h2 id="四、核心方法解析"><a href="#四、核心方法解析" class="headerlink" title="四、核心方法解析"></a>四、核心方法解析</h2><p>hash()<br>第一步，拿到key.hashCode()</p>
<p>第二步高16位异或运算<br>（&gt;&gt;&gt; 表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0）</p>
<p>Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里借用一个图来表示整个key.hashcode()变化到下标的处理过程</p>
<p> 通过这个计算过程可以看出，生成的数组下标会因为‘扰动’的增加而减少碰撞的机率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">comparableClassFor()</span><br><span class="line"> &#x2F;**</span><br><span class="line">     * Returns x&#39;s Class if it is of the form &quot;class C implements</span><br><span class="line">     * Comparable&lt;C&gt;&quot;, else null.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        if (x instanceof Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            if ((c &#x3D; x.getClass()) &#x3D;&#x3D; String.class) &#x2F;&#x2F; bypass checks</span><br><span class="line">                return c;</span><br><span class="line">            if ((ts &#x3D; c.getGenericInterfaces()) !&#x3D; null) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    if (((t &#x3D; ts[i]) instanceof ParameterizedType) &amp;&amp;</span><br><span class="line">                            ((p &#x3D; (ParameterizedType)t).getRawType() &#x3D;&#x3D;</span><br><span class="line">                                    Comparable.class) &amp;&amp;</span><br><span class="line">                            (as &#x3D; p.getActualTypeArguments()) !&#x3D; null &amp;&amp;</span><br><span class="line">                            as.length &#x3D;&#x3D; 1 &amp;&amp; as[0] &#x3D;&#x3D; c) &#x2F;&#x2F; type arg is c</span><br><span class="line">                        return c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns k.compareTo(x) if x matches kc (k&#39;s screened comparable</span><br><span class="line">     * class), else 0.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) &#x2F;&#x2F; for cast to Comparable</span><br><span class="line">    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123;</span><br><span class="line">        return (x &#x3D;&#x3D; null || x.getClass() !&#x3D; kc ? 0 :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tableSizeFor()<br> 【作用】返回给定目标容量的2倍幂。将我们传入的容量设置为大于并最接近的2^N</p>
<p> 【解读】</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36766417/article/details/109047673">求一个数字大于并最接近的2^N</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;补位，将原本为0的空位填补为1，最后加1时，最高有效位进1，其余变为0,如此就可以取到最近的2的幂</span><br><span class="line"> static final int tableSizeFor(int cap) &#123;</span><br><span class="line">     &#x2F;&#x2F;减一后，最右一位肯定和cap的最右一位不同，即一个为0，一个为1</span><br><span class="line">     int n &#x3D; cap - 1;</span><br><span class="line">     &#x2F;&#x2F;（&gt;&gt;&gt;）无符号右移一位，（|）按位或</span><br><span class="line">     n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">     &#x2F;&#x2F;（&gt;&gt;&gt;）无符号右移两位，（|）按位或</span><br><span class="line">     n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">     &#x2F;&#x2F;（&gt;&gt;&gt;）无符号右移四位，（|）按位或</span><br><span class="line">     n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">     &#x2F;&#x2F;（&gt;&gt;&gt;）无符号右移八位，（|）按位或</span><br><span class="line">     n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">     &#x2F;&#x2F;（&gt;&gt;&gt;）无符号右移十六位，（|）按位或，为何到16呢，存疑</span><br><span class="line">     n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">     return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>HashMap()<br>  指定了初始容量和加载因子，会对参数进行校验<br>  初始容量不能为负数，不能大于最大容量 1 &lt;&lt; 30 （2^30）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + </span><br><span class="line">    initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        &#125;</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    public HashMap() &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param   m the map whose mappings are to be placed in this map</span><br><span class="line">     * @throws  NullPointerException if the specified map is null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap1(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">get()</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F;还是先计算 哈希值</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    &#x2F;&#x2F;tab 指向哈希表，n 为哈希表的长度，first 为 (n - 1) &amp; hash 位置处的桶中的头一个节点</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果桶里第一个元素就相等，直接返回</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        &#x2F;&#x2F;否则就得慢慢遍历找</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                &#x2F;&#x2F;如果是树形节点，就调用树形节点的 get 方法</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                &#x2F;&#x2F;do-while 遍历链表的所有节点</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>put()<br>这里看到知乎一个大神的相关回答，图片描述非常形象，引用如下：</p>
<p>（大神回答链接如下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21673805%EF%BC%89">https://zhuanlan.zhihu.com/p/21673805）</a><br>     如果定位到的数组位置没有元素就直接插入；<br>     如果定位到的数组位置有元素就要与插入的key比较，<br>     如果key相同就直接覆盖，<br>     如果key不相同，就判断p是否是一个树节点，<br>     如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入；<br>     如果不是就遍历链表尾部插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F; 1.校验table是否为空或者length等于0，如果是则调用resize方法进行初始化</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; 2.通过hash值计算索引位置，将该索引位置的头节点赋值给p，如果p为空则直接在该索引位置新增一个节点即可</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; table表该索引位置不为空，则进行查找</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 3.判断p节点的key和hash值是否跟传入的相等，如果相等, 则p节点即为要查找的目标节点，将p节点赋值给e节点</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 4.判断p节点是否为TreeNode, 如果是则调用红黑树的putTreeVal方法查找目标节点</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 5.走到这代表p节点为普通链表节点，则调用普通的链表方法进行查找，使用binCount统计链表的节点数</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 6.如果p的next节点为空时，则代表找不到目标节点，则新增一个节点并插入链表尾部</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F; 7.校验节点数是否超过8个，如果超过则调用treeifyBin方法将链表节点转为红黑树节点，</span><br><span class="line">                    &#x2F;&#x2F; 减一是因为循环是从p节点的下一个节点开始的</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 8.如果e节点存在hash值和key值都与传入的相同，则e节点即为目标节点，跳出循环</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;  &#x2F;&#x2F; 将p指向下一个节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 9.如果e节点不为空，则代表目标节点存在，使用传入的value覆盖该节点的value，并返回oldValue</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e); &#x2F;&#x2F; 用于LinkedHashMap</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F; 10.如果插入节点后节点数超过阈值，则调用resize方法进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);  &#x2F;&#x2F; 用于LinkedHashMap</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>resize()<br>扩容，1.7的扩容里，变化长度后所有的hashcode都要重新计算，消耗较大。1.8的扩容里，机制变得更加巧妙，节省计算，具体变化以后再进行学习。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 1.老表的容量不为0，即老表不为空</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.1 判断老表的容量是否超过最大容量值：如果超过则将阈值设置为Integer.MAX_VALUE，并直接返回老表,</span><br><span class="line">        &#x2F;&#x2F; 此时oldCap * 2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 1.2 将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap&gt;&#x3D;16, 则将新阈值设置为原来的两倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2.如果老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值</span><br><span class="line">    else if (oldThr &gt; 0)</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 3.老表的容量为0, 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 4.如果新表的阈值为空, 则通过新的容量*负载因子获得阈值</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 5.将当前阈值设置为刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    &#x2F;&#x2F; 6.如果老表不为空，则需遍历所有节点，将节点赋值给新表</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;  &#x2F;&#x2F; 将索引值为j的老表头节点赋值给e</span><br><span class="line">                oldTab[j] &#x3D; null; &#x2F;&#x2F; 将老表的节点设置为空, 以便垃圾收集器回收空间</span><br><span class="line">                &#x2F;&#x2F; 7.如果e.next为空, 则代表老表的该位置只有1个节点，计算新表的索引位置, 直接将该节点放在该位置</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; 8.如果是红黑树节点，则进行红黑树的重hash分布(跟链表的hash分布基本相同)</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F; 9.如果是普通的链表节点，则进行普通的重hash分布</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null; &#x2F;&#x2F; 存储索引位置为:“原索引位置”的节点</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null; &#x2F;&#x2F; 存储索引位置为:“原索引位置+oldCap”的节点</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        &#x2F;&#x2F; 9.1 如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null) &#x2F;&#x2F; 如果loTail为空, 代表该节点为第一个节点</span><br><span class="line">                                loHead &#x3D; e; &#x2F;&#x2F; 则将loHead赋值为第一个节点</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;    &#x2F;&#x2F; 否则将节点添加在loTail后面</span><br><span class="line">                            loTail &#x3D; e; &#x2F;&#x2F; 并将loTail赋值为新增的节点</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 9.2 如果e的hash值与老表的容量进行与运算为非0,则扩容后的索引位置为:老表的索引位置＋oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null) &#x2F;&#x2F; 如果hiTail为空, 代表该节点为第一个节点</span><br><span class="line">                                hiHead &#x3D; e; &#x2F;&#x2F; 则将hiHead赋值为第一个节点</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;    &#x2F;&#x2F; 否则将节点添加在hiTail后面</span><br><span class="line">                            hiTail &#x3D; e; &#x2F;&#x2F; 并将hiTail赋值为新增的节点</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    &#x2F;&#x2F; 10.如果loTail不为空（说明老表的数据有分布到新表上“原索引位置”的节点），则将最后一个节点</span><br><span class="line">                    &#x2F;&#x2F; 的next设为空，并将新表上索引位置为“原索引位置”的节点设置为对应的头节点</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 11.如果hiTail不为空（说明老表的数据有分布到新表上“原索引+oldCap位置”的节点），则将最后</span><br><span class="line">                    &#x2F;&#x2F; 一个节点的next设为空，并将新表上索引位置为“原索引+oldCap”的节点设置为对应的头节点</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 12.返回新表</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>treeifyBin()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将链表节点转为红黑树节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F; 1.如果table为空或者table的长度小于64, 调用resize方法进行扩容</span><br><span class="line">    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    &#x2F;&#x2F; 2.根据hash值计算索引值，将该索引位置的节点赋值给e，从e开始遍历该索引位置的链表</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F; 3.将链表节点转红黑树节点</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">            &#x2F;&#x2F; 4.如果是第一次遍历，将头节点赋值给hd</span><br><span class="line">            if (tl &#x3D;&#x3D; null)	&#x2F;&#x2F; tl为空代表为第一次循环</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; 5.如果不是第一次遍历，则处理当前节点的prev属性和上一个节点的next属性</span><br><span class="line">                p.prev &#x3D; tl;    &#x2F;&#x2F; 当前节点的prev属性设为上一个节点</span><br><span class="line">                tl.next &#x3D; p;    &#x2F;&#x2F; 上一个节点的next属性设置为当前节点</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 6.将p节点赋值给tl，用于在下一次循环中作为上一个节点进行一些链表的关联操作（p.prev &#x3D; tl 和 tl.next &#x3D; p）</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#x2F;&#x2F; 7.将table该索引位置赋值为新转的TreeNode的头节点，如果该节点不为空，则以以头节点(hd)为根节点, 构建红黑树</span><br><span class="line">        if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>compute() </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public V compute(K key,</span><br><span class="line">                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">    if (remappingFunction &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    TreeNode&lt;K,V&gt; t &#x3D; null;</span><br><span class="line">    Node&lt;K,V&gt; old &#x3D; null;</span><br><span class="line">    if (size &gt; threshold || (tab &#x3D; table) &#x3D;&#x3D; null ||</span><br><span class="line">        (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    if ((first &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        if (first instanceof TreeNode)</span><br><span class="line">            old &#x3D; (t &#x3D; (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e &#x3D; first; K k;</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old &#x3D; e;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue &#x3D; (old &#x3D;&#x3D; null) ? null : old.value;</span><br><span class="line">    V v &#x3D; remappingFunction.apply(key, oldValue);</span><br><span class="line">    if (old !&#x3D; null) &#123;</span><br><span class="line">        if (v !&#x3D; null) &#123;</span><br><span class="line">            old.value &#x3D; v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            removeNode(hash, key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (v !&#x3D; null) &#123;</span><br><span class="line">        if (t !&#x3D; null)</span><br><span class="line">            t.putTreeVal(this, tab, hash, key, v);</span><br><span class="line">        else &#123;</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, v, first);</span><br><span class="line">            if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、面试题"><a href="#五、面试题" class="headerlink" title="五、面试题"></a>五、面试题</h2><h3 id="hashMap与hashTable区别"><a href="#hashMap与hashTable区别" class="headerlink" title="hashMap与hashTable区别"></a>hashMap与hashTable区别</h3><p>HashMap 允许 key 和 value 为 null，Hashtable 不允许。<br>HashMap 的默认初始容量为 16，Hashtable 为 11。<br>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。<br>HashMap 是非线程安全的，Hashtable是线程安全的。<br>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。<br>HashMap 去掉了 Hashtable 中的 contains 方法。<br>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</p>
<h3 id="谈一下1-7和1-8中hashMap的优化"><a href="#谈一下1-7和1-8中hashMap的优化" class="headerlink" title="谈一下1.7和1.8中hashMap的优化"></a>谈一下1.7和1.8中hashMap的优化</h3><p>底层数据结构，增加了红黑树这一结构，默认变化阀值是数组长度&gt;64,链表长度&gt;8，查找操作需要遍历node数组节点下的链表，当桶的长度过长时，会降低查询效率，所以1.8中增加红黑树，这种结构在数据量大的时候增删改查操作更快，当链表长度降低&lt;=6时,红黑树重新转化为链表，链表O(n)，红黑树O(logn)<br>优化高位运算的hash算法，h^(h&gt;&gt;&gt;16)，扰动四次变为扰动一次，提高效率<br>添加时，头插变为尾插，头插法会使链表发生反转，多线程环境下头插会产生环，尾插则不会发生反转，更安全<br>优化扩容机制，resize()扩容机制，扩容的阀值=设定容量<em>载荷因子（16</em>0.75），达到阀值时，扩容成当前的2倍。这中间消耗性能最大的就是扩容后index值的重新计算，index=h&amp;(length-1)，1.8中进行了优化，扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变</p>
<h3 id="HashMap是线程安全的吗？有什么办法线程安全吗"><a href="#HashMap是线程安全的吗？有什么办法线程安全吗" class="headerlink" title="HashMap是线程安全的吗？有什么办法线程安全吗"></a>HashMap是线程安全的吗？有什么办法线程安全吗</h3><p>不是线程安全，1.7中会出现链表循环，插入重复，在源码中没有关于锁的操作。<br>实现线程安全，有三种方法，Tablemap，ConcerrentHashMap,以及Collections.synchronizedMap，tableMap对整个操作方法进行锁定，粒度过大，基本不存在合适的使用场景，Collections.synchronizedMap是Collections里面的内部类，把map传入内部定义的带锁的synchronizedMap对象，可以实现线程安全，ConcerrentHashMap使用分段锁(锁住当前节点)，CAS+synchronized，降低锁粒度，提高并发量</p>
<h3 id="hash函数是怎么设计的"><a href="#hash函数是怎么设计的" class="headerlink" title="hash函数是怎么设计的"></a>hash函数是怎么设计的</h3><p>  先拿到key的hashcode(32位)然后让hashcode的高16与低16位进行异或运算</p>
<p>static final int hash(Object key) {<br>    int h;<br>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}</p>
<h3 id="能详细说一下嘛，这样做有什么好处"><a href="#能详细说一下嘛，这样做有什么好处" class="headerlink" title="能详细说一下嘛，这样做有什么好处"></a>能详细说一下嘛，这样做有什么好处</h3><p>这个有人叫它扰动函数，对hashcode的高十六位与低十六位进行了异或运算<br>好处有两个：</p>
<p>位运算，可以提高算法的运算效率<br>不会造成因为高位没有参与下标的计算而增加的碰撞，增加hashcode的散列性,<br>为什么这样设计可以增加散列性<br>        key.hashCode()是来自key本身hash值，本身太大，所以要与数组length-1做与运算（有0则0）。<br>这样操作固然可以让数变得很小，但也产生了一个问题，那就是只会取到最后几位，碰撞的几率会增大。<br>所以这就需要一个方法来增加要取模的数据的变动性，上面的hash中高位异或的操作就是为了解决这个问题而设计，<br>它将原始哈希码的高位和低位做异或混合，以此来加大低位的随机性。</p>
<h3 id="LinkedHashMap怎么实现有序的"><a href="#LinkedHashMap怎么实现有序的" class="headerlink" title="LinkedHashMap怎么实现有序的"></a>LinkedHashMap怎么实现有序的</h3><p>LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，<br>还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。 </p>
<h3 id="讲一下几个主要函数的逻辑思路吧"><a href="#讲一下几个主要函数的逻辑思路吧" class="headerlink" title="讲一下几个主要函数的逻辑思路吧"></a>讲一下几个主要函数的逻辑思路吧</h3><p>get(),put(),resize(),replace(),remove()<br>涉及put&amp;replace、remove等发生变动的操作，需要如下验证及处理：</p>
<p>数组是否为空——put&amp;replace操作创建，remove操作返回</p>
<p>目标数组是否存在、key是否存在——数组存在则判断节点，put&amp;replace操作（节点存在则替换，节点不存在则创建），      remove操作（节点存在则删除，节点不存在则返回）</p>
<h3 id="节点存储形式是链表还是红黑树"><a href="#节点存储形式是链表还是红黑树" class="headerlink" title="节点存储形式是链表还是红黑树"></a>节点存储形式是链表还是红黑树</h3><p>操作完成后，是否达到扩容/缩减阀值 ——扩容/红黑树与链表转换</p>
<p>其他详细分析见上面主要方法分析</p>
<p>六、参考资料<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/java_wxid/article/details/106896221?utm_source=app">https://blog.csdn.net/java_wxid/article/details/106896221?utm_source=app</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21673805">https://zhuanlan.zhihu.com/p/21673805</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/78996181">https://blog.csdn.net/v123411739/article/details/78996181</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012211603/article/details/79879944">https://blog.csdn.net/u012211603/article/details/79879944</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41345773/article/details/92066554">https://blog.csdn.net/qq_41345773/article/details/92066554</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jdjdndhj/article/details/54407252">https://blog.csdn.net/jdjdndhj/article/details/54407252</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/53358305">https://blog.csdn.net/u011240877/article/details/53358305</a></p>
<pre><code>


</code></pre>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/" rel="tag"># 基础梳理</a>
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          
            <a href="/tags/hashMap/" rel="tag"># hashMap</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/undefined/%E5%B9%B6%E5%8F%91%E4%B8%80%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87%EF%BC%89/" rel="next" title="并发一">
                <i class="fa fa-chevron-left"></i> 并发一
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/undefined/%E5%BB%BA%E7%AB%99/" rel="prev" title="建站">
                建站 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/panda.jpg"
                alt="人和" />
            
              <p class="site-author-name" itemprop="name">人和</p>
              <p class="site-description motion-element" itemprop="description">而吾与子之所共识</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/renhe1997" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="1084028573@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_36766417?spm=1010.2135.3001.5343" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-CSDN"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">一、主要特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">二、继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">三、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.</span> <span class="nav-text">主要元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">四、核心方法解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">五、面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hashMap%E4%B8%8EhashTable%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">hashMap与hashTable区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8B1-7%E5%92%8C1-8%E4%B8%ADhashMap%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">谈一下1.7和1.8中hashMap的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="nav-number">5.3.</span> <span class="nav-text">HashMap是线程安全的吗？有什么办法线程安全吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="nav-number">5.4.</span> <span class="nav-text">hash函数是怎么设计的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%98%9B%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%81%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="nav-number">5.5.</span> <span class="nav-text">能详细说一下嘛，这样做有什么好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E7%9A%84"><span class="nav-number">5.6.</span> <span class="nav-text">LinkedHashMap怎么实现有序的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%BB%E8%BE%91%E6%80%9D%E8%B7%AF%E5%90%A7"><span class="nav-number">5.7.</span> <span class="nav-text">讲一下几个主要函数的逻辑思路吧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F%E6%98%AF%E9%93%BE%E8%A1%A8%E8%BF%98%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">5.8.</span> <span class="nav-text">节点存储形式是链表还是红黑树</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">人和</span>
</div>
        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
